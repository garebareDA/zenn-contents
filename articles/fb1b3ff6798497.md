---
title: "Rustで自作言語のインタプリタを作った話"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust"]
published: false
publication_name: "smartcamp"
---


# リポジトリ
https://github.com/garebareDA/koto

# 前提
字句解析、構文解析を理解または記事を読んでいることを前提として話します。
そしてインタプリタに関してはウェブの情報を下に作成した独自のものなのでおそらく本来イメージするものではないと思われます。Rustにメモリを生やすというわけ変わらん実装になってます。

## 字句解析器
https://zenn.dev/smartcamp/articles/a498830e010e18

## 構文解析器
https://zenn.dev/smartcamp/articles/076b673e2782d6

# インタプリタとは
随時解釈しながら実行するプログラムのことです。直接解釈実行するタイプ、中言語を介するタイプなどがあります。
今回の作成したインタプリタの場合は構文木を直接実行しています。Rustの配列を仮想のメモリとして扱っているので仮想マシンに近い実装なのかなぁと勝手思っています。
そして構文分析器とかなり密結合な設計となっています。

# インタプリタで実装したこと
- ミュータブル、イミュータブルな変数
- 関数
- 四則演算
- for
- if
- 配列

## ミュータブル、イミュータブルな変数
変数がミュータブルかイミュータブルかは構文解析時にノードに`Bool`で設定されています。
参照するために全て仮想メモリの配列に保存されています。
```rust
asts::Types::Variable(var) => {
...
```
matchを使いノードの`Types`が`Variable`だった場合中身を取り出します`var`の中に`name`というプロパティがあり、仮想メモリの配列から名前に合致するものを取得します。

## 関数
関数には関数自体を定義をしているノード`Call`と関数を実行しているノード`Function`があります。
### 関数の定義
関数の定義自体は構文解析で行われており、`Function`のノードは全て仮想メモリの配列に保存されています

### 関数の呼び出し
```rust
asts::Types::Call(function) => {
  let result = vec_function.function_run(function, vec_variable);
  match result {
    Some(_) => {
      return (false, result);
    }

    None => {
      return (true, None);
    }
  }
```
matchを使いノードの`Type`が`Call`だった場合関数を呼び出す処理に入ります。
`vec_variable`は変数が保存されている配列です。

```rust
let callee = &call_ast.callee;
if callee == "print" {
    let value = &call_ast.argument[0];
    match value {
        asts::Types::Variable(var) => {
            let (var_result, _) = variable.search_variable(&var, self);
            self.print_var(&var_result[0]);

        asts::Types::Binary(_) => {
            let result = interpreters::calculation(&value, variable, self);
            self.print_var(&result);

        _ => {
            self.print_var(&value);
        }
    }
}
```
`function_run`で実際の関数を実行しています。
`Call`ノードの中には`callee`という関数名を保存してあるプロパティがありそれがビルトイン関数の`print`だった場合引数のプロパティから値をノードを取り出しRustの`println!`で実行しています。
他の関数の呼び出しだった場合は`Function`の配列から同じ名前のものを取り出し中身のノードを実行します。

## for
Rustのfo分を使いループの処理を行っています。
## if
Rustのif文を使い条件分岐を行っています。
## 配列
構文解析時にすでに配列を作っておきます。

# スコープと仮想メモリ