---
title: "Discordã®botã‚’ffmpegã‚’ä½¿ã£ã¦éŸ³å£°ã‚’æµã™æ–¹æ³•"
emoji: "ğŸ»"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "bot", "discord"]
published: true
---

# äº‹å‰æº–å‚™
ä»Šå›ã¯Goã§å®Ÿè£…ã—ã¾ã™ã€‚
ffmpegã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãŠãã¾ã™ã€‚
Discordã®Botã‚’ä½œæˆã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—ã—ã¾ã™ã€‚
ãã—ã¦Botã‚’æ§‹ç¯‰ã—ã¦ãŠãã¾ã™ã€‚

```go
func main() {
	dg, err := discordgo.New("Bot " + "Token")
	if err != nil {
		fmt.Println("error creating Discord session,", err)
		return
	}

	dg.AddHandler(MusicPlay)

	err = dg.Open()
	if err != nil {
		fmt.Println("error opening connection,", err)
		return
	}

	fmt.Println("Bot is now running.  Press CTRL-C to exit.")
	sc := make(chan os.Signal, 1)
	signal.Notify(sc, syscall.SIGINT, syscall.SIGTERM, os.Interrupt, os.Kill)
	<-sc

	dg.Close()
}
```

# ãƒãƒ£ãƒƒãƒˆã‹ã‚‰éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®å–å¾—
ffmpegã§URLã‚’æŒ‡å®šã™ã‚Œã°ãªã‚“ã§ã‚‚å†ç”Ÿã§ãã¾ã™ãŒä»Šå›ã¯ãƒãƒ£ãƒƒãƒˆã‹ã‚‰éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã¦å†ç”Ÿã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚

```go
func MusicPlay(s*discordgo.Session, m *discordgo.Message) {
  if m.Author.ID == s.State.User.ID {
		return
	}

	if len(m.Message.Attachments) != 1 {
		return
	}

  url := m.Message.Attachments[0].URL
	sp := strings.Split(url, ".")
	l := len(sp) - 1
	if len(sp) != 2 && !(sp[l] == "mp3" || sp[l] == "wav") {
		return
	}

  v, err := c.ChannelVoiceJoin(s, m.Message)
	if err != nil {
		s.ChannelMessageSend(m.ChannelID, "ãƒœã‚¤ã‚¹ãƒãƒ£ãƒ³ãƒãƒ«ã«å…¥ã‚Œã¾ã›ã‚“")
		return
	}

  ctx, cancel := context.WithCancel(context.Background())
  Play(s, m, v, ctx, url)
}
```

ã¨ã‚Šã‚ãˆãš`m.Message.Attachments`ãŒ1ä»¥ä¸Šã‚ã‚Œã°ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã¨ã—ã¦å–å¾—ã—ã¾ã™ã€‚
æ‹¡å¼µå­ãŒmp3ã¾ãŸã¯wavãªã‚‰`c.ChannelVoiceJoin(s, m.Message)`ã§éŸ³å£°ãƒãƒ£ãƒ³ãƒãƒ«ã«å‚åŠ ã—ã¾ã™ã€‚

# ffmpegã®æ§‹é€ ä½“ã‚’ä½œæˆ
```go
type ffmpeg struct {
  *exec.Cmd
}

func NewFfmpeg() (*ffmpeg, error) {
	cmdPath, err := exec.LookPath("ffmpeg")
	if err != nil {
		return nil, err
	}

	return &ffmpeg{
		exec.CommandContext(
			context.Background(),
			cmdPath,
		),
		}, nil
}

func (f *ffmpeg) SetArgs(args ...string) {
	f.Args = append(f.Args, args...)
}

func (f *ffmpeg) Start(output string) error {
	f.SetArgs(output)
	return f.Cmd.Start()
}

func (f *ffmpeg) Kill() error {
	return f.Cmd.Process.Kill()
}

func (f *ffmpeg) Play(buf *bufio.Reader, send chan[]int16 , ctx context.Context) error {
	for {
		audiobuf := make([]int16, 960*2)
		if err := binary.Read(buf, binary.LittleEndian, &audiobuf); err != nil {
			return err
		}
		select {
		case send <- audiobuf:
			continue
		case <-ctx.Done():
			return nil
		}
	}
}
```
å˜ç´”ã«ffmpegã‚’Goã‹ã‚‰å®Ÿè¡Œã™ã‚‹æ§‹é€ ä½“ã§ã™ã€‚
`Play`é–¢æ•°ã§ffmpegã‹ã‚‰å—ã‘å–ã£ãŸãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§sendã«ãƒãƒ£ãƒãƒ«ã§é€ã‚Šã¾ã™ã€‚

# å†ç”Ÿéƒ¨åˆ†ã®å®Ÿè£…
```go
func Play(s *discordgo.Session, m *discordgo.Message, v *discordgo.VoiceConnection, url string, ctx context.Context) error {
	ffmpegCmd, err := NewFfmpeg()
	if err != nil {
		return err
	}

	ffmpegArgs := []string{
		"-i", url,
		"-f", "s16le",
		"-ar", "48000",
		"-ac", "2",
	}

	ffmpegCmd.SetArgs(ffmpegArgs...)
	ffmpegout, err := ffmpegCmd.StdoutPipe()
	if err != nil {
		return err
	}

	ffmpegbuf := bufio.NewReaderSize(ffmpegout, 16384)
	err = ffmpegCmd.Start("pipe:1")
	if err != nil {
		log.Println("ffmpeg error:" + err.Error())
		return err
	}

	go func(ctx context.Context) {
		<-ctx.Done()
		log.Println("ffmpeg done")
		err = ffmpegCmd.Kill()
		if err != nil {
			log.Println("ffmpeg kill error:" + err.Error())
			return
		}
	}(ctx)

	go func(ctx context.Context) {
		v.Speaking(true)
		send := make(chan []int16, 2)
		defer close(send)
		defer v.Speaking(false)

		go func() {
			dgvoice.SendPCM(v, send)
		}()

		err := ffmpegCmd.Play(ffmpegbuf, send, ctx)
		if err != nil {
			return
		}
	}(ctx)

	return nil
}
```
éƒ¨åˆ†éƒ¨åˆ†ã«åˆ‡ã‚Šå–ã£ã¦è¦‹ã¦ã„ãã¾ã™ã€‚

## ffmpegã®å®Ÿè¡Œ
```go
	ffmpegCmd, err := NewFfmpeg()
	if err != nil {
		return err
	}

	ffmpegArgs := []string{
		"-i", url,
		"-f", "s16le",
		"-ar", "48000",
		"-ac", "2",
	}

  ffmpegCmd.SetArgs(ffmpegArgs...)
	ffmpegout, err := ffmpegCmd.StdoutPipe()
	if err != nil {
		return err
	}

	ffmpegbuf := bufio.NewReaderSize(ffmpegout, 16384)
	err = ffmpegCmd.Start("pipe:1")
	if err != nil {
		log.Println("ffmpeg error:" + err.Error())
		return err
	}
```
ffmpegã®å¼•æ•°ã«Discordã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å–å¾—ã—ãŸURLã‚’ã—ã¦ã„ã‚‹æŒ‡å®šã—ã¦ã¾ã™ã€‚`ffmpegCmd.Start("pipe:1")`ã§æ¨™æº–å‡ºåŠ›ã«å‡ºåŠ›ã™ã‚‹ã“ã¨ã‚’æŒ‡å®šã—ã¦ã„ã¾ã™ã€‚
`	ffmpegout, err := ffmpegCmd.StdoutPipe()`ã§æ¨™æº–å‡ºåŠ›ã‹ã‚‰å—ã‘å–ã£ã¦ã„ã¾ã™ã€‚

## çµ‚äº†ã‚’æ¤œçŸ¥
```go
	go func(ctx context.Context) {
		<-ctx.Done()
		log.Println("ffmpeg done")
		err = ffmpegCmd.Kill()
		if err != nil {
			log.Println("ffmpeg kill error:" + err.Error())
			return
		}
	}(ctx)
```
ã“ã®éƒ¨åˆ†ã§éŸ³æ¥½ã®çµ‚äº†ã‚’æ¤œçŸ¥ã—ã¦ffmpegã‚’killã—ã¦ã„ã¾ã™ã€‚

## ãƒœã‚¤ã‚¹ãƒãƒ£ãƒ³ãƒãƒ«ã«é€ä¿¡
```go
	go func(ctx context.Context) {
		v.Speaking(true)
		send := make(chan []int16, 2)
		defer close(send)
		defer v.Speaking(false)

		go func() {
			dgvoice.SendPCM(v, send)
		}()

		err := ffmpegCmd.Play(ffmpegbuf, send, ctx)
		if err != nil {
			return
		}
	}(ctx)
```
dgvoiceã®`SendPCM(v, send)`ã§`ffmpegCmd.Play()`ã‹ã‚‰é€ã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’Discordã®ãƒãƒ£ãƒ³ãƒãƒ«ã«é€ä¿¡ã—ã¦ã„ã¾ã™ã€‚

# çµ‚ã‚ã‚Š
çµ‚ã‚ã‚Šã€‚
é©å½“ã«ãƒãƒªã§ä½œã£ãŸã®ã§é–“é•ã„ãŒã‚ã‚Œã°æ•™ãˆã¦ä¸‹ã•ã„ã€‚
